# 题目
 有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。

第 i 件物品的体积是 vi，价值是 wi
。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

输出最优选法的方案数。注意答案可能很大，请输出答案模 109+7 的结果。

## 输入格式
第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。

接下来有 N 行，每行两个整数 vi, wi，用空格隔开，分别表示第 i 件物品的体积和价值。

## 输出格式
输出一个整数，表示方案数模 10^9+7 的结果。

## 数据范围
0<N, V≤1000

0<vi, wi≤1000
## 输入样例
4 5
1 2
2 4
3 4
4 6
## 输出样例 ：
2

# 思路
·这一题我们只要在原来的背包模型的基础上加一个 cnt 数组，用来统计每一个容量下的总次数，更新时也很简单，只要出现了一次，我们的 cnt[j]数组就对应直接加上 1 即可。到最后我们只需要输出就可以了
·需要注意的是，只有在上一次更新了我们的结果时，我们才去更新我们的呢 cnt 数组，否则会有错误的情况。
·
# AC 代码
```cpp
#include<cstdio>

const int N = 1010, mod = 1e9 + 7;

int f[N], cnt[N];
int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    for(int i = 0; i <= m; i ++)  cnt[i] = 1;

    for(int i = 1; i <= n; i ++) {
        int v, w;
        scanf("%d%d", &v, &w);
        for(int j = m; j >= v; j --) {
            int value = f[j - v] + w;
            if(value > f[j]) {
                f[j] = value;
                cnt[j] = cnt[j - v];
            } else if(value == f[j]) {
                cnt[j] = (cnt[j] + cnt[j - v]) % mod;
            }
        }
    }

    printf("%d", cnt[m]);
    return 0;
}

```
# 备注
